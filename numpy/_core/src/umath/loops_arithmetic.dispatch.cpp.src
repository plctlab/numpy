#include "loops_utils.h"
#include "loops.h"
#include "lowlevel_strided_loops.h"
// Provides the various *_LOOP macros
#include "fast_loop_macros.h"

#include <hwy/highway.h>
#include "simd/simd.hpp"
using namespace np::simd;

//###############################################################################
//## Division
//###############################################################################
/********************************************************************************
 ** Defining the SIMD kernels
 *
 * Floor division of signed is based on T. Granlund and P. L. Montgomery
 * "Division by invariant integers using multiplication(see [Figure 6.1]
 * https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.2556)"
 * For details on TRUNC division see simd/intdiv.h for more clarification
 ***********************************************************************************
 ** Figure 6.1: Signed division by run-time invariant divisor, rounded towards -INF
 ***********************************************************************************
 * For q = FLOOR(a/d), all sword:
 *     sword -dsign = SRL(d, N - 1);
 *     uword -nsign = (n < -dsign);
 *     uword -qsign = EOR(-nsign, -dsign);
 *     q = TRUNC((n - (-dsign ) + (-nsign))/d) - (-qsign);
 ********************************************************************************/

#if (defined(HWY_ARCH_VSX) && !defined(HWY_ARCH_VSX4)) || defined(HWY_ARCH_NEON) || defined(HWY_ARCH_LSX)
    // Due to integer 128-bit multiplication emulation, SIMD 64-bit division
    // may not perform well on both neon and up to VSX3 compared to scalar
    // division.
    #define SIMD_DISABLE_DIV64_OPT
#endif

#if NPY_HWY
/**begin repeat
 * Signed types
 * #sfx    = s8, s16, s32, s64#
 * #len    = 8,  16,  32,  64#
 */
#if @len@ < 64 || (@len@ == 64 && !defined(SIMD_DISABLE_DIV64_OPT))
static inline void
simd_divide_by_scalar_contig_@sfx@(char **args, npy_intp len)
{
    using T = int@len@_t;
    T *src   = (T *) args[0];
    T scalar = *(T *) args[1];
    T *dst   = (T *) args[2];
    const int vstep = Lanes<T>();

    if (scalar == 0) {
        std::fill(dst, dst + len, 0);
        npy_set_floatstatus_divbyzero();
    }
    else if (scalar == 1) {
        if (src != dst) {
            std::copy(src, src + len, dst);
        }
    }
    else if (scalar == -1) {
        bool raise_err = false;
        auto vec_min = Set<T>(std::numeric_limits<T>::min());
        for (; len >= vstep; len -= vstep, src += vstep, dst += vstep) {
            auto vec_src = LoadU<T>(src);
            auto is_min = Eq(vec_src, vec_min);
            auto vec_res = hn::IfThenElse(is_min, vec_min, hn::Neg(vec_src));
            StoreU<T>(vec_res, dst);
            if (!raise_err && !hn::AllFalse(_Tag<T>(), is_min)) {
                raise_err = true;
            }
        }

        for (; len > 0; --len, ++src, ++dst) {
            T val = *src;
            if (val == std::numeric_limits<T>::min()) {
                *dst = std::numeric_limits<T>::min();
                raise_err = true;
            } else {
                *dst = -val;
            }
        }
        if (raise_err) {
            npy_set_floatstatus_overflow();
        }
    }
    else {
        auto vec_scalar = Set<T>(scalar);
        for (; len >= vstep; len -= vstep, src += vstep, dst += vstep) {
            auto vec_src = LoadU<T>(src);
            auto vec_div = Div(vec_src, vec_scalar);
            auto vec_mul = Mul(vec_div, vec_scalar);
            auto eq_mask = Eq(vec_src, vec_mul);
            auto diff_signs = hn::IsNegative(Xor(vec_src, vec_scalar));
            auto adjust = AndNot(eq_mask, diff_signs);

            vec_div = hn::MaskedSubOr(vec_div, adjust, vec_div, Set<T>(1));
            StoreU<T>(vec_div, dst);
        }

        for (; len > 0; --len, ++src, ++dst) {
            const T a = *src;
            T r = a / scalar;
            // Negative quotients needs to be rounded down
            if (((a > 0) != (scalar > 0)) && ((r * scalar) != a)) {
                r--;
            }
            *dst = r;
        }
    }
}
#endif
/**end repeat**/
#endif // NPY_SIMD

/**begin repeat
 * Unsigned types
 * #sfx    = u8, u16, u32, u64#
 * #len    = 8,  16,  32,  64#
 */
#if @len@ < 64 || (@len@ == 64 && !defined(SIMD_DISABLE_DIV64_OPT))
static inline void
simd_divide_by_scalar_contig_@sfx@(char **args, npy_intp len)
{
    using T = uint@len@_t;
    T *src   = (T *) args[0];
    T scalar = *(T *) args[1];
    T *dst   = (T *) args[2];
    const int vstep = Lanes<T>();

    if (scalar == 0) {
        std::fill(dst, dst + len, 0);
        npy_set_floatstatus_divbyzero();
    }
    else if (scalar == 1) {
        if (src != dst) {
            std::copy(src, src + len, dst);
        }
    }
    else {
        for (; len >= vstep; len -= vstep, src += vstep, dst += vstep) {
            StoreU<T>(Div(LoadU<T>(src), Set<T>(scalar)), dst);
        }

        for (; len > 0; --len, ++src, ++dst) {
            const T a = *src;
            *dst = a / scalar;
        }
    }
}
#endif
/**end repeat**/

/********************************************************************************
 ** Defining ufunc inner functions
 ********************************************************************************/

/**begin repeat
 * Signed types
 *  #type  = npy_byte, npy_short, npy_int, npy_long, npy_longlong#
 *  #TYPE  = BYTE,     SHORT,     INT,     LONG,     LONGLONG#
 */
#undef TO_SIMD_SFX
#if 0
/**begin repeat1
 * #len = 8, 16, 32, 64#
 */
#elif NPY_BITSOF_@TYPE@ == @len@
    #define TO_SIMD_SFX(X) X##_s@len@
/**end repeat1**/
#endif
#if NPY_BITSOF_@TYPE@ == 64 && defined(SIMD_DISABLE_DIV64_OPT)
    #undef TO_SIMD_SFX
#endif

NPY_FINLINE @type@ floor_div_@TYPE@(const @type@ n, const @type@ d)
{
    /*
     * FIXME: On x86 at least, dividing the smallest representable integer
     * by -1 causes a SIFGPE (division overflow). We treat this case here
     * (to avoid a SIGFPE crash at python level), but a good solution would
     * be to treat integer division problems separately from FPU exceptions
     * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
     */
    if (NPY_UNLIKELY(d == 0 || (n == NPY_MIN_@TYPE@ && d == -1))) {
        if (d == 0) {
            npy_set_floatstatus_divbyzero();
            return 0;
        }
        else {
            npy_set_floatstatus_overflow();
            return NPY_MIN_@TYPE@;
        }
    }
    @type@ r = n / d;
    // Negative quotients needs to be rounded down
    if (((n > 0) != (d > 0)) && ((r * d) != n)) {
        r--;
    }
    return r;
}

NPY_NO_EXPORT void NPY_CPU_DISPATCH_CURFX(@TYPE@_divide)
(char **args, npy_intp const *dimensions, npy_intp const *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(@type@) {
            io1 = floor_div_@TYPE@(io1, *(@type@*)ip2);
        }
        *((@type@ *)iop1) = io1;
    }
#if NPY_HWY && defined(TO_SIMD_SFX)
    // for contiguous block of memory, divisor is a scalar and not 0
    else if (IS_BLOCKABLE_BINARY_SCALAR2(sizeof(@type@), NPY_SIMD_WIDTH) &&
             (*(@type@ *)args[1]) != 0) {
        TO_SIMD_SFX(simd_divide_by_scalar_contig)(args, dimensions[0]);
    }
#endif
    else {
        BINARY_LOOP {
            *((@type@ *)op1) = floor_div_@TYPE@(*(@type@*)ip1, *(@type@*)ip2);
        }
    }
}

NPY_NO_EXPORT int NPY_CPU_DISPATCH_CURFX(@TYPE@_divide_indexed)
(PyArrayMethod_Context *NPY_UNUSED(context), char * const*args, npy_intp const *dimensions, npy_intp const *steps, NpyAuxData *NPY_UNUSED(func))
{
    char *ip1 = args[0];
    char *indxp = args[1];
    char *value = args[2];
    npy_intp is1 = steps[0], isindex = steps[1], isb = steps[2];
    npy_intp shape = steps[3];
    npy_intp n = dimensions[0];
    npy_intp i;
    @type@ *indexed;
    for(i = 0; i < n; i++, indxp += isindex, value += isb) {
        npy_intp indx = *(npy_intp *)indxp;
        if (indx < 0) {
            indx += shape;
        }
        indexed = (@type@ *)(ip1 + is1 * indx);
        *indexed = floor_div_@TYPE@(*indexed, *(@type@ *)value);
    }
    return 0;
}

/**end repeat**/

/**begin repeat
 * Unsigned types
 *  #type  = npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong#
 *  #TYPE  = UBYTE,     USHORT,     UINT,     ULONG,     ULONGLONG#
 *  #STYPE = BYTE,      SHORT,      INT,      LONG,      LONGLONG#
 */
#undef TO_SIMD_SFX
#if 0
/**begin repeat1
 * #len = 8, 16, 32, 64#
 */
#elif NPY_BITSOF_@STYPE@ == @len@
    #define TO_SIMD_SFX(X) X##_u@len@
/**end repeat1**/
#endif
/*
 * For 64-bit division on Armv7, Aarch64, and IBM/Power, NPYV fall-backs to the scalar division
 * because emulating multiply-high on these architectures is going to be expensive comparing
 * to the native scalar dividers.
 * Therefore it's better to disable NPYV in this special case to avoid any unnecessary shuffles.
 * Power10(VSX4) is an exception here since it has native support for integer vector division.
 */
#if NPY_BITSOF_@STYPE@ == 64 && !defined(HWY_ARCH_VSX4) && (defined(HWY_ARCH_VSX) || defined(HWY_ARCH_NEON) || defined(HWY_ARCH_LSX))
    #undef TO_SIMD_SFX
#endif
NPY_NO_EXPORT void NPY_CPU_DISPATCH_CURFX(@TYPE@_divide)
(char **args, npy_intp const *dimensions, npy_intp const *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(@type@) {
            const @type@ d = *(@type@ *)ip2;
            if (NPY_UNLIKELY(d == 0)) {
                npy_set_floatstatus_divbyzero();
                io1 = 0;
            } else {
                io1 /= d;
            }
        }
        *((@type@ *)iop1) = io1;
    }
#if NPY_HWY && defined(TO_SIMD_SFX)
    // for contiguous block of memory, divisor is a scalar and not 0
    else if (IS_BLOCKABLE_BINARY_SCALAR2(sizeof(@type@), NPY_SIMD_WIDTH) &&
             (*(@type@ *)args[1]) != 0) {
        TO_SIMD_SFX(simd_divide_by_scalar_contig)(args, dimensions[0]);
    }
#endif
    else {
        BINARY_LOOP {
            const @type@ in1 = *(@type@ *)ip1;
            const @type@ in2 = *(@type@ *)ip2;
            if (NPY_UNLIKELY(in2 == 0)) {
                npy_set_floatstatus_divbyzero();
                *((@type@ *)op1) = 0;
            } else{
                *((@type@ *)op1) = in1 / in2;
            }
        }
    }
}

NPY_NO_EXPORT int NPY_CPU_DISPATCH_CURFX(@TYPE@_divide_indexed)
(PyArrayMethod_Context *NPY_UNUSED(context), char * const*args, npy_intp const *dimensions, npy_intp const *steps, NpyAuxData *NPY_UNUSED(func))
{
    char *ip1 = args[0];
    char *indxp = args[1];
    char *value = args[2];
    npy_intp is1 = steps[0], isindex = steps[1], isb = steps[2];
    npy_intp shape = steps[3];
    npy_intp n = dimensions[0];
    npy_intp i;
    @type@ *indexed;
    for(i = 0; i < n; i++, indxp += isindex, value += isb) {
        npy_intp indx = *(npy_intp *)indxp;
        if (indx < 0) {
            indx += shape;
        }
        indexed = (@type@ *)(ip1 + is1 * indx);
        @type@ in2 = *(@type@ *)value;
        if (NPY_UNLIKELY(in2 == 0)) {
            npy_set_floatstatus_divbyzero();
            *indexed = 0;
        } else {
            *indexed = *indexed / in2;
        }
    }
    return 0;
}

/**end repeat**/
